# IR Feedback Analysis

Feedback received from an agent integrating aliter into a native application.

## Original Feedback

> 1. VBox y-values are confusing: They're CSS top offsets (larger = lower), which is counter-intuitive for math rendering. A baseline-relative coordinate system (positive y = up) would be more portable.
> 2. Zero widths: Many elements have width: 0.0 because HTML relies on auto-sizing. This makes explicit sizing in non-CSS renderers difficult. Could aliter compute actual widths from font metrics?
> 3. Superscript/subscript positioning: The IR doesn't give y-offsets for sup/sub - it relies on CSS class detection ("sup", "sub"). Explicit positioning would be more portable.
> 4. Semantic info: Having semantic variants in MathElement (like Superscript { base, script } or Fraction { numerator, denominator, bar }) rather than just preserving HTML structure with CSS classes would make non-HTML rendering much easier.

## Analysis

### Current Architecture

The IR is currently generated by **converting the HTML output** (via `from_html::convert`), not directly from the parse tree:

```
LaTeX → Parser → ParseNode → HTML Builder → HtmlNode → IR (current)
                     ↓
                 (proposed) → IR Builder → IR (native)
```

### 1. VBox Y-Values

**Current state**: The IR actually uses baseline-relative coordinates (positive y = up) — see `ir.rs:46`. The conversion from HTML inverts CSS `top` values:

```rust
// ir.rs:621
.map(|v| -v) // top is inverted
```

**Issue**: The feedback is about the HTML intermediate representation, not the final IR. When converting HTML→IR, `top` CSS offsets must be inverted. The IR itself is already correct, but:
- The conversion can lose precision
- Complex VList positioning semantics are flattened

**A native IR builder** would compute y-offsets directly from font metrics (`sup1`, `sub1`, etc. in `font_metrics.rs:69-76`) rather than extracting from CSS.

### 2. Zero Widths

**Current state**: `MathElement::Text::dimensions()` uses a **placeholder**:
```rust
// ir.rs:280
let width = text.chars().count() as f64 * 0.5 * style.size;
```

**Available data**: Character widths ARE available via `get_character_metrics()`:
```rust
// font_metrics.rs:278-284
pub struct CharacterMetrics {
    pub depth: f64,
    pub height: f64,
    pub italic: f64,
    pub skew: f64,
    pub width: f64,  // <-- per-character width available
}
```

**Fix options**:
1. **Quick fix**: Improve `MathElement::Text::dimensions()` to use font metrics
2. **Better fix**: Native IR builder computes real widths during construction and stores them explicitly

### 3. Superscript/Subscript Positioning

**Current state** (functions/mod.rs:117-158): Simple supsub uses CSS classes:
```rust
make_span(vec!["sup".to_string()], vec![sup], ...)  // No y-offset!
```

The positioning is entirely CSS-based. When converted to IR, these become HBoxes with children at `y=0` — the CSS class info is lost.

**Solution**: A native IR builder would:
- Look up `sup1`/`sup2`/`sup3` and `sub1`/`sub2` from font metrics
- Compute actual y-offsets and store them in `Positioned<T>`

### 4. Semantic Information

**Current state**: The IR is **layout-centric**, not semantic. A fraction is:
```
HBox { VBox { numerator, Rule, denominator } }
```
Not:
```
Fraction { numerator, denominator, bar_thickness }
```

**Trade-offs**:

| Approach | Pros | Cons |
|----------|------|------|
| Layout-only (current) | Simpler, works for any expression | Backend must reverse-engineer semantics |
| Semantic IR | Better for native renderers | More complex, must handle all cases |
| Hybrid (tags/annotations) | Preserve semantics optionally | More data to carry |

## Recommendations

### Option A: Native IR Builder (Recommended)

Add a new builder that produces IR directly from `ParseNode`:

```rust
// New module: src/ir_builder.rs
pub fn build_ir(tree: &ParseNode, options: &Options) -> MathLayout {
    // Build IR directly, with:
    // - Real widths from font metrics
    // - Explicit y-offsets for sup/sub
    // - Optional semantic variants
}
```

**Benefits**:
- Full access to font metrics during construction
- Semantic information from ParseNode is directly available
- No CSS conversion step
- Can add semantic variants to `MathElement` (e.g., `Fraction`, `Superscript`)

### Option B: Improve HTML→IR Conversion (Incremental)

1. Fix `Text::dimensions()` to use font metrics
2. Detect "sup"/"sub" classes and compute y-offsets from metrics
3. Add heuristic detection for fractions, sqrt, etc.

This is more work for less payoff than Option A.

### Semantic IR Extension (for either approach)

If semantic variants are desired:

```rust
pub enum MathElement {
    // ... existing layout variants ...

    // Semantic variants (optional)
    Superscript {
        base: Box<Positioned<MathElement>>,
        script: Box<Positioned<MathElement>>,
    },
    Subscript { ... },
    Fraction {
        numerator: Box<MathElement>,
        denominator: Box<MathElement>,
        bar_thickness: f64,
    },
    SquareRoot {
        radicand: Box<MathElement>,
        index: Option<Box<MathElement>>,
    },
    // etc.
}
```

## Decision

Proceeding with **Option A: Native IR Builder** implementation.
