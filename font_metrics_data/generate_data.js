// The font_metrics.json file is copied from the KaTeX fontMetricsData.js file
// We have to remove the export and some extra commas to make it json
// and then we can use this script to generate the appropriate Rust file for the data

// The format I decide upon was
// type MetricData = [5; f64];
// const {NAME}: &'static [(u16, MetricData)] = &[...]

let fs = require('fs');

const FONT_METRICS_FILE = "../src/font_metrics_data.rs";

let data = fs.readFileSync("./font_metrics.json");
let pdata = JSON.parse(data);

fs.unlinkSync(FONT_METRICS_FILE);
let output = fs.createWriteStream(FONT_METRICS_FILE);

output.write("//! This file is generated by the generate_data.js script.\n");
output.write("//! Do not edit this file directly.\n\n");
output.write("pub(crate) type MetricData = [f64; 5];\n");

// Return the name of the key suitable for being used in a constant
function constKey(key) {
    return key.replace("-", "_").toUpperCase();
}

let keys = Object.keys(pdata);
for (let i = 0; i < keys.length; i++) {
    let key = keys[i];
    let val = pdata[key];

    let key_res = constKey(key);
    output.write("const " + key_res + ": &'static [(u16, MetricData)] = &[\n");
    for (part in val) {
        // Parse the key as a number
        let part_val = val[part];
        let part_val_res = part_val
            .map(x => x.toString())
            .map(x => {
                if (!x.includes(".")) {
                    return x + ".0";
                } else {
                    return x;
                }
            })
            .join(", ");

        let res = "\t(" + part + ", [" + part_val_res + "]),\n";
        output.write(res);
    }
    output.write("];\n\n");
}

output.write("pub(crate) fn get_metric(font: &str) -> Option<&'static [(u16, MetricData)]> {\n\tSome(match font {\n");
for (let i = 0; i < keys.length; i++) {
    let key = keys[i];
    let key_res = constKey(key);

    output.write("\t\t\"" + key + "\" => " + key_res + ",\n");
}
output.write("\t\t_ => return None,\n\t})\n}");

output.close();